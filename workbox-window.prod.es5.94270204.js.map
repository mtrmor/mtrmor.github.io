{"mappings":"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","sources":["<anon>","node_modules/workbox-window/build/workbox-window.prod.es5.mjs","node_modules/workbox-window/_version.js","node_modules/workbox-window/messageSW.js","node_modules/workbox-core/_version.js","node_modules/workbox-core/_private/Deferred.js","node_modules/workbox-window/utils/urlsMatch.js","node_modules/workbox-window/utils/WorkboxEvent.js","node_modules/workbox-window/Workbox.js","node_modules/workbox-core/_private/dontWaitFor.js","node_modules/workbox-window/utils/WorkboxEventTarget.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequiref5f3\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"4Vc2z\", function(module, exports) {\n\n$parcel$export(module.exports, \"Workbox\", () => $d967af77e2ca9dcf$export$7e2ffb4f33d5ddf0);\ntry {\n    self[\"workbox:window:7.0.0\"] && _();\n} catch (n) {}\nfunction $d967af77e2ca9dcf$export$3a89f7c6642e8f16(n, t) {\n    return new Promise(function(r) {\n        var e = new MessageChannel;\n        e.port1.onmessage = function(n) {\n            r(n.data);\n        }, n.postMessage(t, [\n            e.port2\n        ]);\n    });\n}\nfunction $d967af77e2ca9dcf$var$t(n) {\n    var t = function(n, t) {\n        if (\"object\" != typeof n || !n) return n;\n        var r = n[Symbol.toPrimitive];\n        if (void 0 !== r) {\n            var e = r.call(n, t || \"default\");\n            if (\"object\" != typeof e) return e;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === t ? String : Number)(n);\n    }(n, \"string\");\n    return \"symbol\" == typeof t ? t : t + \"\";\n}\nfunction $d967af77e2ca9dcf$var$r(n, r) {\n    for(var e = 0; e < r.length; e++){\n        var i = r[e];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(n, $d967af77e2ca9dcf$var$t(i.key), i);\n    }\n}\nfunction $d967af77e2ca9dcf$var$e(n, t) {\n    return $d967af77e2ca9dcf$var$e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, t) {\n        return n.__proto__ = t, n;\n    }, $d967af77e2ca9dcf$var$e(n, t);\n}\nfunction $d967af77e2ca9dcf$var$i(n, t) {\n    (null == t || t > n.length) && (t = n.length);\n    for(var r = 0, e = new Array(t); r < t; r++)e[r] = n[r];\n    return e;\n}\nfunction $d967af77e2ca9dcf$var$o(n, t) {\n    var r = \"undefined\" != typeof Symbol && n[Symbol.iterator] || n[\"@@iterator\"];\n    if (r) return (r = r.call(n)).next.bind(r);\n    if (Array.isArray(n) || (r = function(n, t) {\n        if (n) {\n            if (\"string\" == typeof n) return $d967af77e2ca9dcf$var$i(n, t);\n            var r = Object.prototype.toString.call(n).slice(8, -1);\n            return \"Object\" === r && n.constructor && (r = n.constructor.name), \"Map\" === r || \"Set\" === r ? Array.from(n) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? $d967af77e2ca9dcf$var$i(n, t) : void 0;\n        }\n    }(n)) || t && n && \"number\" == typeof n.length) {\n        r && (n = r);\n        var e = 0;\n        return function() {\n            return e >= n.length ? {\n                done: !0\n            } : {\n                done: !1,\n                value: n[e++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\ntry {\n    self[\"workbox:core:7.0.0\"] && _();\n} catch (n) {}\nvar $d967af77e2ca9dcf$var$u = function() {\n    var n = this;\n    this.promise = new Promise(function(t, r) {\n        n.resolve = t, n.reject = r;\n    });\n};\nfunction $d967af77e2ca9dcf$var$a(n, t) {\n    var r = location.href;\n    return new URL(n, r).href === new URL(t, r).href;\n}\nvar $d967af77e2ca9dcf$export$207d7db167ba3e92 = function(n, t) {\n    this.type = n, Object.assign(this, t);\n};\nfunction $d967af77e2ca9dcf$var$f(n, t, r) {\n    return r ? t ? t(n) : n : (n && n.then || (n = Promise.resolve(n)), t ? n.then(t) : n);\n}\nfunction $d967af77e2ca9dcf$var$s() {}\nvar $d967af77e2ca9dcf$var$v = {\n    type: \"SKIP_WAITING\"\n};\nfunction $d967af77e2ca9dcf$var$h(n, t) {\n    if (!t) return n && n.then ? n.then($d967af77e2ca9dcf$var$s) : Promise.resolve();\n}\nvar $d967af77e2ca9dcf$export$7e2ffb4f33d5ddf0 = function(t) {\n    function i(n, r) {\n        var e, i;\n        return void 0 === r && (r = {}), (e = t.call(this) || this).nn = {}, e.tn = 0, e.rn = new $d967af77e2ca9dcf$var$u, e.en = new $d967af77e2ca9dcf$var$u, e.on = new $d967af77e2ca9dcf$var$u, e.un = 0, e.an = new Set, e.cn = function() {\n            var n = e.fn, t = n.installing;\n            e.tn > 0 || !$d967af77e2ca9dcf$var$a(t.scriptURL, e.sn.toString()) || performance.now() > e.un + 6e4 ? (e.vn = t, n.removeEventListener(\"updatefound\", e.cn)) : (e.hn = t, e.an.add(t), e.rn.resolve(t)), ++e.tn, t.addEventListener(\"statechange\", e.ln);\n        }, e.ln = function(n) {\n            var t = e.fn, r = n.target, i = r.state, o = r === e.vn, u = {\n                sw: r,\n                isExternal: o,\n                originalEvent: n\n            };\n            !o && e.mn && (u.isUpdate = !0), e.dispatchEvent(new $d967af77e2ca9dcf$export$207d7db167ba3e92(i, u)), \"installed\" === i ? e.wn = self.setTimeout(function() {\n                \"installed\" === i && t.waiting === r && e.dispatchEvent(new $d967af77e2ca9dcf$export$207d7db167ba3e92(\"waiting\", u));\n            }, 200) : \"activating\" === i && (clearTimeout(e.wn), o || e.en.resolve(r));\n        }, e.yn = function(n) {\n            var t = e.hn, r = t !== navigator.serviceWorker.controller;\n            e.dispatchEvent(new $d967af77e2ca9dcf$export$207d7db167ba3e92(\"controlling\", {\n                isExternal: r,\n                originalEvent: n,\n                sw: t,\n                isUpdate: e.mn\n            })), r || e.on.resolve(t);\n        }, e.gn = (i = function(n) {\n            var t = n.data, r = n.ports, i = n.source;\n            return $d967af77e2ca9dcf$var$f(e.getSW(), function() {\n                e.an.has(i) && e.dispatchEvent(new $d967af77e2ca9dcf$export$207d7db167ba3e92(\"message\", {\n                    data: t,\n                    originalEvent: n,\n                    ports: r,\n                    sw: i\n                }));\n            });\n        }, function() {\n            for(var n = [], t = 0; t < arguments.length; t++)n[t] = arguments[t];\n            try {\n                return Promise.resolve(i.apply(this, n));\n            } catch (n) {\n                return Promise.reject(n);\n            }\n        }), e.sn = n, e.nn = r, navigator.serviceWorker.addEventListener(\"message\", e.gn), e;\n    }\n    var o, s;\n    s = t, (o = i).prototype = Object.create(s.prototype), o.prototype.constructor = o, $d967af77e2ca9dcf$var$e(o, s);\n    var l, m, w, y = i.prototype;\n    return y.register = function(n) {\n        var t = (void 0 === n ? {} : n).immediate, r = void 0 !== t && t;\n        try {\n            var e = this;\n            return $d967af77e2ca9dcf$var$f(function(n, t) {\n                var r = n();\n                if (r && r.then) return r.then(t);\n                return t(r);\n            }(function() {\n                if (!r && \"complete\" !== document.readyState) return $d967af77e2ca9dcf$var$h(new Promise(function(n) {\n                    return window.addEventListener(\"load\", n);\n                }));\n            }, function() {\n                return e.mn = Boolean(navigator.serviceWorker.controller), e.dn = e.pn(), $d967af77e2ca9dcf$var$f(e.bn(), function(n) {\n                    e.fn = n, e.dn && (e.hn = e.dn, e.en.resolve(e.dn), e.on.resolve(e.dn), e.dn.addEventListener(\"statechange\", e.ln, {\n                        once: !0\n                    }));\n                    var t = e.fn.waiting;\n                    return t && $d967af77e2ca9dcf$var$a(t.scriptURL, e.sn.toString()) && (e.hn = t, Promise.resolve().then(function() {\n                        e.dispatchEvent(new $d967af77e2ca9dcf$export$207d7db167ba3e92(\"waiting\", {\n                            sw: t,\n                            wasWaitingBeforeRegister: !0\n                        }));\n                    }).then(function() {})), e.hn && (e.rn.resolve(e.hn), e.an.add(e.hn)), e.fn.addEventListener(\"updatefound\", e.cn), navigator.serviceWorker.addEventListener(\"controllerchange\", e.yn), e.fn;\n                });\n            }));\n        } catch (n) {\n            return Promise.reject(n);\n        }\n    }, y.update = function() {\n        try {\n            return this.fn ? $d967af77e2ca9dcf$var$f($d967af77e2ca9dcf$var$h(this.fn.update())) : $d967af77e2ca9dcf$var$f();\n        } catch (n) {\n            return Promise.reject(n);\n        }\n    }, y.getSW = function() {\n        return void 0 !== this.hn ? Promise.resolve(this.hn) : this.rn.promise;\n    }, y.messageSW = function(t) {\n        try {\n            return $d967af77e2ca9dcf$var$f(this.getSW(), function(r) {\n                return $d967af77e2ca9dcf$export$3a89f7c6642e8f16(r, t);\n            });\n        } catch (n) {\n            return Promise.reject(n);\n        }\n    }, y.messageSkipWaiting = function() {\n        this.fn && this.fn.waiting && $d967af77e2ca9dcf$export$3a89f7c6642e8f16(this.fn.waiting, $d967af77e2ca9dcf$var$v);\n    }, y.pn = function() {\n        var n = navigator.serviceWorker.controller;\n        return n && $d967af77e2ca9dcf$var$a(n.scriptURL, this.sn.toString()) ? n : void 0;\n    }, y.bn = function() {\n        try {\n            var n = this;\n            return $d967af77e2ca9dcf$var$f(function(n, t) {\n                try {\n                    var r = n();\n                } catch (n) {\n                    return t(n);\n                }\n                if (r && r.then) return r.then(void 0, t);\n                return r;\n            }(function() {\n                return $d967af77e2ca9dcf$var$f(navigator.serviceWorker.register(n.sn, n.nn), function(t) {\n                    return n.un = performance.now(), t;\n                });\n            }, function(n) {\n                throw n;\n            }));\n        } catch (n) {\n            return Promise.reject(n);\n        }\n    }, l = i, m = [\n        {\n            key: \"active\",\n            get: function() {\n                return this.en.promise;\n            }\n        },\n        {\n            key: \"controlling\",\n            get: function() {\n                return this.on.promise;\n            }\n        }\n    ], $d967af77e2ca9dcf$var$r(l.prototype, m), w && $d967af77e2ca9dcf$var$r(l, w), Object.defineProperty(l, \"prototype\", {\n        writable: !1\n    }), l;\n}(function() {\n    function n() {\n        this.Pn = new Map;\n    }\n    var t = n.prototype;\n    return t.addEventListener = function(n, t) {\n        this.jn(n).add(t);\n    }, t.removeEventListener = function(n, t) {\n        this.jn(n).delete(t);\n    }, t.dispatchEvent = function(n) {\n        n.target = this;\n        for(var t, r = $d967af77e2ca9dcf$var$o(this.jn(n.type)); !(t = r()).done;)(0, t.value)(n);\n    }, t.jn = function(n) {\n        return this.Pn.has(n) || this.Pn.set(n, new Set), this.Pn.get(n);\n    }, n;\n}());\n\n});\n\n\n//# sourceMappingURL=workbox-window.prod.es5.94270204.js.map\n","try{self[\"workbox:window:7.0.0\"]&&_()}catch(n){}function n(n,t){return new Promise((function(r){var e=new MessageChannel;e.port1.onmessage=function(n){r(n.data)},n.postMessage(t,[e.port2])}))}function t(n){var t=function(n,t){if(\"object\"!=typeof n||!n)return n;var r=n[Symbol.toPrimitive];if(void 0!==r){var e=r.call(n,t||\"default\");if(\"object\"!=typeof e)return e;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===t?String:Number)(n)}(n,\"string\");return\"symbol\"==typeof t?t:t+\"\"}function r(n,r){for(var e=0;e<r.length;e++){var i=r[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(n,t(i.key),i)}}function e(n,t){return e=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,t){return n.__proto__=t,n},e(n,t)}function i(n,t){(null==t||t>n.length)&&(t=n.length);for(var r=0,e=new Array(t);r<t;r++)e[r]=n[r];return e}function o(n,t){var r=\"undefined\"!=typeof Symbol&&n[Symbol.iterator]||n[\"@@iterator\"];if(r)return(r=r.call(n)).next.bind(r);if(Array.isArray(n)||(r=function(n,t){if(n){if(\"string\"==typeof n)return i(n,t);var r=Object.prototype.toString.call(n).slice(8,-1);return\"Object\"===r&&n.constructor&&(r=n.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(n):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?i(n,t):void 0}}(n))||t&&n&&\"number\"==typeof n.length){r&&(n=r);var e=0;return function(){return e>=n.length?{done:!0}:{done:!1,value:n[e++]}}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}try{self[\"workbox:core:7.0.0\"]&&_()}catch(n){}var u=function(){var n=this;this.promise=new Promise((function(t,r){n.resolve=t,n.reject=r}))};function a(n,t){var r=location.href;return new URL(n,r).href===new URL(t,r).href}var c=function(n,t){this.type=n,Object.assign(this,t)};function f(n,t,r){return r?t?t(n):n:(n&&n.then||(n=Promise.resolve(n)),t?n.then(t):n)}function s(){}var v={type:\"SKIP_WAITING\"};function h(n,t){if(!t)return n&&n.then?n.then(s):Promise.resolve()}var l=function(t){function i(n,r){var e,i;return void 0===r&&(r={}),(e=t.call(this)||this).nn={},e.tn=0,e.rn=new u,e.en=new u,e.on=new u,e.un=0,e.an=new Set,e.cn=function(){var n=e.fn,t=n.installing;e.tn>0||!a(t.scriptURL,e.sn.toString())||performance.now()>e.un+6e4?(e.vn=t,n.removeEventListener(\"updatefound\",e.cn)):(e.hn=t,e.an.add(t),e.rn.resolve(t)),++e.tn,t.addEventListener(\"statechange\",e.ln)},e.ln=function(n){var t=e.fn,r=n.target,i=r.state,o=r===e.vn,u={sw:r,isExternal:o,originalEvent:n};!o&&e.mn&&(u.isUpdate=!0),e.dispatchEvent(new c(i,u)),\"installed\"===i?e.wn=self.setTimeout((function(){\"installed\"===i&&t.waiting===r&&e.dispatchEvent(new c(\"waiting\",u))}),200):\"activating\"===i&&(clearTimeout(e.wn),o||e.en.resolve(r))},e.yn=function(n){var t=e.hn,r=t!==navigator.serviceWorker.controller;e.dispatchEvent(new c(\"controlling\",{isExternal:r,originalEvent:n,sw:t,isUpdate:e.mn})),r||e.on.resolve(t)},e.gn=(i=function(n){var t=n.data,r=n.ports,i=n.source;return f(e.getSW(),(function(){e.an.has(i)&&e.dispatchEvent(new c(\"message\",{data:t,originalEvent:n,ports:r,sw:i}))}))},function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];try{return Promise.resolve(i.apply(this,n))}catch(n){return Promise.reject(n)}}),e.sn=n,e.nn=r,navigator.serviceWorker.addEventListener(\"message\",e.gn),e}var o,s;s=t,(o=i).prototype=Object.create(s.prototype),o.prototype.constructor=o,e(o,s);var l,m,w,y=i.prototype;return y.register=function(n){var t=(void 0===n?{}:n).immediate,r=void 0!==t&&t;try{var e=this;return f(function(n,t){var r=n();if(r&&r.then)return r.then(t);return t(r)}((function(){if(!r&&\"complete\"!==document.readyState)return h(new Promise((function(n){return window.addEventListener(\"load\",n)})))}),(function(){return e.mn=Boolean(navigator.serviceWorker.controller),e.dn=e.pn(),f(e.bn(),(function(n){e.fn=n,e.dn&&(e.hn=e.dn,e.en.resolve(e.dn),e.on.resolve(e.dn),e.dn.addEventListener(\"statechange\",e.ln,{once:!0}));var t=e.fn.waiting;return t&&a(t.scriptURL,e.sn.toString())&&(e.hn=t,Promise.resolve().then((function(){e.dispatchEvent(new c(\"waiting\",{sw:t,wasWaitingBeforeRegister:!0}))})).then((function(){}))),e.hn&&(e.rn.resolve(e.hn),e.an.add(e.hn)),e.fn.addEventListener(\"updatefound\",e.cn),navigator.serviceWorker.addEventListener(\"controllerchange\",e.yn),e.fn}))})))}catch(n){return Promise.reject(n)}},y.update=function(){try{return this.fn?f(h(this.fn.update())):f()}catch(n){return Promise.reject(n)}},y.getSW=function(){return void 0!==this.hn?Promise.resolve(this.hn):this.rn.promise},y.messageSW=function(t){try{return f(this.getSW(),(function(r){return n(r,t)}))}catch(n){return Promise.reject(n)}},y.messageSkipWaiting=function(){this.fn&&this.fn.waiting&&n(this.fn.waiting,v)},y.pn=function(){var n=navigator.serviceWorker.controller;return n&&a(n.scriptURL,this.sn.toString())?n:void 0},y.bn=function(){try{var n=this;return f(function(n,t){try{var r=n()}catch(n){return t(n)}if(r&&r.then)return r.then(void 0,t);return r}((function(){return f(navigator.serviceWorker.register(n.sn,n.nn),(function(t){return n.un=performance.now(),t}))}),(function(n){throw n})))}catch(n){return Promise.reject(n)}},l=i,(m=[{key:\"active\",get:function(){return this.en.promise}},{key:\"controlling\",get:function(){return this.on.promise}}])&&r(l.prototype,m),w&&r(l,w),Object.defineProperty(l,\"prototype\",{writable:!1}),l}(function(){function n(){this.Pn=new Map}var t=n.prototype;return t.addEventListener=function(n,t){this.jn(n).add(t)},t.removeEventListener=function(n,t){this.jn(n).delete(t)},t.dispatchEvent=function(n){n.target=this;for(var t,r=o(this.jn(n.type));!(t=r()).done;){(0,t.value)(n)}},t.jn=function(n){return this.Pn.has(n)||this.Pn.set(n,new Set),this.Pn.get(n)},n}());export{l as Workbox,c as WorkboxEvent,n as messageSW};\n//# sourceMappingURL=workbox-window.prod.es5.mjs.map\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:window:7.0.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport './_version.js';\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n * @memberof workbox-window\n */\n// Better not change type of data.\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction messageSW(sw, data) {\n    return new Promise((resolve) => {\n        const messageChannel = new MessageChannel();\n        messageChannel.port1.onmessage = (event) => {\n            resolve(event.data);\n        };\n        sw.postMessage(data, [messageChannel.port2]);\n    });\n}\nexport { messageSW };\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:core:7.0.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nclass Deferred {\n    /**\n     * Creates a promise and exposes its resolve and reject functions as methods.\n     */\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nexport { Deferred };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nexport function urlsMatch(url1, url2) {\n    const { href } = location;\n    return new URL(url1, href).href === new URL(url2, href).href;\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nexport class WorkboxEvent {\n    constructor(type, props) {\n        this.type = type;\n        Object.assign(this, props);\n    }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { messageSW } from './messageSW.js';\nimport { WorkboxEventTarget } from './utils/WorkboxEventTarget.js';\nimport { urlsMatch } from './utils/urlsMatch.js';\nimport { WorkboxEvent } from './utils/WorkboxEvent.js';\nimport './_version.js';\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n// The de facto standard message that a service worker should be listening for\n// to trigger a call to skipWaiting().\nconst SKIP_WAITING_MESSAGE = { type: 'SKIP_WAITING' };\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires {@link workbox-window.Workbox#message}\n * @fires {@link workbox-window.Workbox#installed}\n * @fires {@link workbox-window.Workbox#waiting}\n * @fires {@link workbox-window.Workbox#controlling}\n * @fires {@link workbox-window.Workbox#activated}\n * @fires {@link workbox-window.Workbox#redundant}\n * @memberof workbox-window\n */\nclass Workbox extends WorkboxEventTarget {\n    /**\n     * Creates a new Workbox instance with a script URL and service worker\n     * options. The script URL and options are the same as those used when\n     * calling [navigator.serviceWorker.register(scriptURL, options)](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).\n     *\n     * @param {string|TrustedScriptURL} scriptURL The service worker script\n     *     associated with this instance. Using a\n     *     [`TrustedScriptURL`](https://web.dev/trusted-types/) is supported.\n     * @param {Object} [registerOptions] The service worker options associated\n     *     with this instance.\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    constructor(scriptURL, registerOptions = {}) {\n        super();\n        this._registerOptions = {};\n        this._updateFoundCount = 0;\n        // Deferreds we can resolve later.\n        this._swDeferred = new Deferred();\n        this._activeDeferred = new Deferred();\n        this._controllingDeferred = new Deferred();\n        this._registrationTime = 0;\n        this._ownSWs = new Set();\n        /**\n         * @private\n         */\n        this._onUpdateFound = () => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const installingSW = registration.installing;\n            // If the script URL passed to `navigator.serviceWorker.register()` is\n            // different from the current controlling SW's script URL, we know any\n            // successful registration calls will trigger an `updatefound` event.\n            // But if the registered script URL is the same as the current controlling\n            // SW's script URL, we'll only get an `updatefound` event if the file\n            // changed since it was last registered. This can be a problem if the user\n            // opens up the same page in a different tab, and that page registers\n            // a SW that triggers an update. It's a problem because this page has no\n            // good way of knowing whether the `updatefound` event came from the SW\n            // script it registered or from a registration attempt made by a newer\n            // version of the page running in another tab.\n            // To minimize the possibility of a false positive, we use the logic here:\n            const updateLikelyTriggeredExternally = \n            // Since we enforce only calling `register()` once, and since we don't\n            // add the `updatefound` event listener until the `register()` call, if\n            // `_updateFoundCount` is > 0 then it means this method has already\n            // been called, thus this SW must be external\n            this._updateFoundCount > 0 ||\n                // If the script URL of the installing SW is different from this\n                // instance's script URL, we know it's definitely not from our\n                // registration.\n                !urlsMatch(installingSW.scriptURL, this._scriptURL.toString()) ||\n                // If all of the above are false, then we use a time-based heuristic:\n                // Any `updatefound` event that occurs long after our registration is\n                // assumed to be external.\n                performance.now() > this._registrationTime + REGISTRATION_TIMEOUT_DURATION\n                ? // If any of the above are not true, we assume the update was\n                    // triggered by this instance.\n                    true\n                : false;\n            if (updateLikelyTriggeredExternally) {\n                this._externalSW = installingSW;\n                registration.removeEventListener('updatefound', this._onUpdateFound);\n            }\n            else {\n                // If the update was not triggered externally we know the installing\n                // SW is the one we registered, so we set it.\n                this._sw = installingSW;\n                this._ownSWs.add(installingSW);\n                this._swDeferred.resolve(installingSW);\n                // The `installing` state isn't something we have a dedicated\n                // callback for, but we do log messages for it in development.\n                if (process.env.NODE_ENV !== 'production') {\n                    if (navigator.serviceWorker.controller) {\n                        logger.log('Updated service worker found. Installing now...');\n                    }\n                    else {\n                        logger.log('Service worker is installing...');\n                    }\n                }\n            }\n            // Increment the `updatefound` count, so future invocations of this\n            // method can be sure they were triggered externally.\n            ++this._updateFoundCount;\n            // Add a `statechange` listener regardless of whether this update was\n            // triggered externally, since we have callbacks for both.\n            installingSW.addEventListener('statechange', this._onStateChange);\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onStateChange = (originalEvent) => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const sw = originalEvent.target;\n            const { state } = sw;\n            const isExternal = sw === this._externalSW;\n            const eventProps = {\n                sw,\n                isExternal,\n                originalEvent,\n            };\n            if (!isExternal && this._isUpdate) {\n                eventProps.isUpdate = true;\n            }\n            this.dispatchEvent(new WorkboxEvent(state, eventProps));\n            if (state === 'installed') {\n                // This timeout is used to ignore cases where the service worker calls\n                // `skipWaiting()` in the install event, thus moving it directly in the\n                // activating state. (Since all service workers *must* go through the\n                // waiting phase, the only way to detect `skipWaiting()` called in the\n                // install event is to observe that the time spent in the waiting phase\n                // is very short.)\n                // NOTE: we don't need separate timeouts for the own and external SWs\n                // since they can't go through these phases at the same time.\n                this._waitingTimeout = self.setTimeout(() => {\n                    // Ensure the SW is still waiting (it may now be redundant).\n                    if (state === 'installed' && registration.waiting === sw) {\n                        this.dispatchEvent(new WorkboxEvent('waiting', eventProps));\n                        if (process.env.NODE_ENV !== 'production') {\n                            if (isExternal) {\n                                logger.warn('An external service worker has installed but is ' +\n                                    'waiting for this client to close before activating...');\n                            }\n                            else {\n                                logger.warn('The service worker has installed but is waiting ' +\n                                    'for existing clients to close before activating...');\n                            }\n                        }\n                    }\n                }, WAITING_TIMEOUT_DURATION);\n            }\n            else if (state === 'activating') {\n                clearTimeout(this._waitingTimeout);\n                if (!isExternal) {\n                    this._activeDeferred.resolve(sw);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                switch (state) {\n                    case 'installed':\n                        if (isExternal) {\n                            logger.warn('An external service worker has installed. ' +\n                                'You may want to suggest users reload this page.');\n                        }\n                        else {\n                            logger.log('Registered service worker installed.');\n                        }\n                        break;\n                    case 'activated':\n                        if (isExternal) {\n                            logger.warn('An external service worker has activated.');\n                        }\n                        else {\n                            logger.log('Registered service worker activated.');\n                            if (sw !== navigator.serviceWorker.controller) {\n                                logger.warn('The registered service worker is active but ' +\n                                    'not yet controlling the page. Reload or run ' +\n                                    '`clients.claim()` in the service worker.');\n                            }\n                        }\n                        break;\n                    case 'redundant':\n                        if (sw === this._compatibleControllingSW) {\n                            logger.log('Previously controlling service worker now redundant!');\n                        }\n                        else if (!isExternal) {\n                            logger.log('Registered service worker now redundant!');\n                        }\n                        break;\n                }\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onControllerChange = (originalEvent) => {\n            const sw = this._sw;\n            const isExternal = sw !== navigator.serviceWorker.controller;\n            // Unconditionally dispatch the controlling event, with isExternal set\n            // to distinguish between controller changes due to the initial registration\n            // vs. an update-check or other tab's registration.\n            // See https://github.com/GoogleChrome/workbox/issues/2786\n            this.dispatchEvent(new WorkboxEvent('controlling', {\n                isExternal,\n                originalEvent,\n                sw,\n                isUpdate: this._isUpdate,\n            }));\n            if (!isExternal) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log('Registered service worker now controlling this page.');\n                }\n                this._controllingDeferred.resolve(sw);\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onMessage = async (originalEvent) => {\n            // Can't change type 'any' of data.\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const { data, ports, source } = originalEvent;\n            // Wait until there's an \"own\" service worker. This is used to buffer\n            // `message` events that may be received prior to calling `register()`.\n            await this.getSW();\n            // If the service worker that sent the message is in the list of own\n            // service workers for this instance, dispatch a `message` event.\n            // NOTE: we check for all previously owned service workers rather than\n            // just the current one because some messages (e.g. cache updates) use\n            // a timeout when sent and may be delayed long enough for a service worker\n            // update to be found.\n            if (this._ownSWs.has(source)) {\n                this.dispatchEvent(new WorkboxEvent('message', {\n                    // Can't change type 'any' of data.\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    data,\n                    originalEvent,\n                    ports,\n                    sw: source,\n                }));\n            }\n        };\n        this._scriptURL = scriptURL;\n        this._registerOptions = registerOptions;\n        // Add a message listener immediately since messages received during\n        // page load are buffered only until the DOMContentLoaded event:\n        // https://github.com/GoogleChrome/workbox/issues/2202\n        navigator.serviceWorker.addEventListener('message', this._onMessage);\n    }\n    /**\n     * Registers a service worker for this instances script URL and service\n     * worker options. By default this method delays registration until after\n     * the window has loaded.\n     *\n     * @param {Object} [options]\n     * @param {Function} [options.immediate=false] Setting this to true will\n     *     register the service worker immediately, even if the window has\n     *     not loaded (not recommended).\n     */\n    async register({ immediate = false } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._registrationTime) {\n                logger.error('Cannot re-register a Workbox instance after it has ' +\n                    'been registered. Create a new instance instead.');\n                return;\n            }\n        }\n        if (!immediate && document.readyState !== 'complete') {\n            await new Promise((res) => window.addEventListener('load', res));\n        }\n        // Set this flag to true if any service worker was controlling the page\n        // at registration time.\n        this._isUpdate = Boolean(navigator.serviceWorker.controller);\n        // Before registering, attempt to determine if a SW is already controlling\n        // the page, and if that SW script (and version, if specified) matches this\n        // instance's script.\n        this._compatibleControllingSW = this._getControllingSWIfCompatible();\n        this._registration = await this._registerScript();\n        // If we have a compatible controller, store the controller as the \"own\"\n        // SW, resolve active/controlling deferreds and add necessary listeners.\n        if (this._compatibleControllingSW) {\n            this._sw = this._compatibleControllingSW;\n            this._activeDeferred.resolve(this._compatibleControllingSW);\n            this._controllingDeferred.resolve(this._compatibleControllingSW);\n            this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, { once: true });\n        }\n        // If there's a waiting service worker with a matching URL before the\n        // `updatefound` event fires, it likely means that this site is open\n        // in another tab, or the user refreshed the page (and thus the previous\n        // page wasn't fully unloaded before this page started loading).\n        // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n        const waitingSW = this._registration.waiting;\n        if (waitingSW &&\n            urlsMatch(waitingSW.scriptURL, this._scriptURL.toString())) {\n            // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n            // a compatible controller.\n            this._sw = waitingSW;\n            // Run this in the next microtask, so any code that adds an event\n            // listener after awaiting `register()` will get this event.\n            dontWaitFor(Promise.resolve().then(() => {\n                this.dispatchEvent(new WorkboxEvent('waiting', {\n                    sw: waitingSW,\n                    wasWaitingBeforeRegister: true,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn('A service worker was already waiting to activate ' +\n                        'before this script was registered...');\n                }\n            }));\n        }\n        // If an \"own\" SW is already set, resolve the deferred.\n        if (this._sw) {\n            this._swDeferred.resolve(this._sw);\n            this._ownSWs.add(this._sw);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log('Successfully registered service worker.', this._scriptURL.toString());\n            if (navigator.serviceWorker.controller) {\n                if (this._compatibleControllingSW) {\n                    logger.debug('A service worker with the same script URL ' +\n                        'is already controlling this page.');\n                }\n                else {\n                    logger.debug('A service worker with a different script URL is ' +\n                        'currently controlling the page. The browser is now fetching ' +\n                        'the new script now...');\n                }\n            }\n            const currentPageIsOutOfScope = () => {\n                const scopeURL = new URL(this._registerOptions.scope || this._scriptURL.toString(), document.baseURI);\n                const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n                return !location.pathname.startsWith(scopeURLBasePath);\n            };\n            if (currentPageIsOutOfScope()) {\n                logger.warn('The current page is not in scope for the registered ' +\n                    'service worker. Was this a mistake?');\n            }\n        }\n        this._registration.addEventListener('updatefound', this._onUpdateFound);\n        navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange);\n        return this._registration;\n    }\n    /**\n     * Checks for updates of the registered service worker.\n     */\n    async update() {\n        if (!this._registration) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error('Cannot update a Workbox instance without ' +\n                    'being registered. Register the Workbox instance first.');\n            }\n            return;\n        }\n        // Try to update registration\n        await this._registration.update();\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is active. If a service worker was already controlling at registration\n     * time then it will resolve to that if the script URLs (and optionally\n     * script versions) match, otherwise it will wait until an update is found\n     * and activates.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get active() {\n        return this._activeDeferred.promise;\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is controlling the page. If a service worker was already controlling at\n     * registration time then it will resolve to that if the script URLs (and\n     * optionally script versions) match, otherwise it will wait until an update\n     * is found and starts controlling the page.\n     * Note: the first time a service worker is installed it will active but\n     * not start controlling the page unless `clients.claim()` is called in the\n     * service worker.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get controlling() {\n        return this._controllingDeferred.promise;\n    }\n    /**\n     * Resolves with a reference to a service worker that matches the script URL\n     * of this instance, as soon as it's available.\n     *\n     * If, at registration time, there's already an active or waiting service\n     * worker with a matching script URL, it will be used (with the waiting\n     * service worker taking precedence over the active service worker if both\n     * match, since the waiting service worker would have been registered more\n     * recently).\n     * If there's no matching active or waiting service worker at registration\n     * time then the promise will not resolve until an update is found and starts\n     * installing, at which point the installing service worker is used.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    getSW() {\n        // If `this._sw` is set, resolve with that as we want `getSW()` to\n        // return the correct (new) service worker if an update is found.\n        return this._sw !== undefined\n            ? Promise.resolve(this._sw)\n            : this._swDeferred.promise;\n    }\n    /**\n     * Sends the passed data object to the service worker registered by this\n     * instance (via {@link workbox-window.Workbox#getSW}) and resolves\n     * with a response (if any).\n     *\n     * A response can be set in a message handler in the service worker by\n     * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n     * returned by `messageSW()`. If no response is set, the promise will never\n     * resolve.\n     *\n     * @param {Object} data An object to send to the service worker\n     * @return {Promise<Object>}\n     */\n    // We might be able to change the 'data' type to Record<string, unknown> in the future.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    async messageSW(data) {\n        const sw = await this.getSW();\n        return messageSW(sw, data);\n    }\n    /**\n     * Sends a `{type: 'SKIP_WAITING'}` message to the service worker that's\n     * currently in the `waiting` state associated with the current registration.\n     *\n     * If there is no current registration or no service worker is `waiting`,\n     * calling this will have no effect.\n     */\n    messageSkipWaiting() {\n        if (this._registration && this._registration.waiting) {\n            void messageSW(this._registration.waiting, SKIP_WAITING_MESSAGE);\n        }\n    }\n    /**\n     * Checks for a service worker already controlling the page and returns\n     * it if its script URL matches.\n     *\n     * @private\n     * @return {ServiceWorker|undefined}\n     */\n    _getControllingSWIfCompatible() {\n        const controller = navigator.serviceWorker.controller;\n        if (controller &&\n            urlsMatch(controller.scriptURL, this._scriptURL.toString())) {\n            return controller;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Registers a service worker for this instances script URL and register\n     * options and tracks the time registration was complete.\n     *\n     * @private\n     */\n    async _registerScript() {\n        try {\n            // this._scriptURL may be a TrustedScriptURL, but there's no support for\n            // passing that to register() in lib.dom right now.\n            // https://github.com/GoogleChrome/workbox/issues/2855\n            const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions);\n            // Keep track of when registration happened, so it can be used in the\n            // `this._onUpdateFound` heuristic. Also use the presence of this\n            // property as a way to see if `.register()` has been called.\n            this._registrationTime = performance.now();\n            return reg;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(error);\n            }\n            // Re-throw the error.\n            throw error;\n        }\n    }\n}\nexport { Workbox };\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n/**\n * The `message` event is dispatched any time a `postMessage` is received.\n *\n * @event workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {MessagePort[]} ports The `ports` value from `originalEvent`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `installed` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * {@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw|registered service worker}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `waiting` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the {@link workbox-window.Workbox#register}\n * method was called.\n *\n * @event workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original\n *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event, or `undefined` in the case where the service worker was waiting\n *     to before `.register()` was called.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `activated` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * {@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw|registered service worker}\n * changes to `activated`.\n *\n * @event workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `redundant` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n    // Effective no-op.\n    void promise.then(() => { });\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nexport class WorkboxEventTarget {\n    constructor() {\n        this._eventListenerRegistry = new Map();\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    addEventListener(type, listener) {\n        const foo = this._getEventListenersByType(type);\n        foo.add(listener);\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    removeEventListener(type, listener) {\n        this._getEventListenersByType(type).delete(listener);\n    }\n    /**\n     * @param {Object} event\n     * @private\n     */\n    dispatchEvent(event) {\n        event.target = this;\n        const listeners = this._getEventListenersByType(event.type);\n        for (const listener of listeners) {\n            listener(event);\n        }\n    }\n    /**\n     * Returns a Set of listeners associated with the passed event type.\n     * If no handlers have been registered, an empty Set is returned.\n     *\n     * @param {string} type The event type.\n     * @return {Set<ListenerCallback>} An array of handler functions.\n     * @private\n     */\n    _getEventListenersByType(type) {\n        if (!this._eventListenerRegistry.has(type)) {\n            this._eventListenerRegistry.set(type, new Set());\n        }\n        return this._eventListenerRegistry.get(type);\n    }\n}\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","Object","defineProperty","get","$d967af77e2ca9dcf$export$7e2ffb4f33d5ddf0","set","s","enumerable","configurable","self","_","n","$d967af77e2ca9dcf$export$3a89f7c6642e8f16","t","Promise","r","e","MessageChannel","port1","onmessage","data","postMessage","port2","$d967af77e2ca9dcf$var$r","length","i","writable","$d967af77e2ca9dcf$var$t","Symbol","toPrimitive","call","TypeError","String","Number","key","$d967af77e2ca9dcf$var$e","setPrototypeOf","bind","__proto__","$d967af77e2ca9dcf$var$i","Array","$d967af77e2ca9dcf$var$u","promise","resolve","reject","$d967af77e2ca9dcf$var$a","location","href","URL","$d967af77e2ca9dcf$export$207d7db167ba3e92","type","assign","$d967af77e2ca9dcf$var$f","then","$d967af77e2ca9dcf$var$s","$d967af77e2ca9dcf$var$v","$d967af77e2ca9dcf$var$h","nn","tn","rn","en","on","un","an","Set","cn","fn","installing","scriptURL","sn","toString","performance","now","vn","removeEventListener","hn","add","addEventListener","ln","target","state","o","u","sw","isExternal","originalEvent","mn","isUpdate","dispatchEvent","wn","setTimeout","waiting","clearTimeout","yn","navigator","serviceWorker","controller","gn","ports","source","getSW","has","arguments","apply","prototype","create","constructor","m","w","y","immediate","document","readyState","window","Boolean","dn","pn","bn","once","wasWaitingBeforeRegister","update","messageSW","messageSkipWaiting","l","Pn","Map","jn","delete","$d967af77e2ca9dcf$var$o","iterator","next","isArray","slice","name","from","test","done","value","messageChannel","event","Deferred","_this","this","urlsMatch","url1","url2","WorkboxEvent","props","_await","direct","_empty","SKIP_WAITING_MESSAGE","_awaitIgnored","Workbox","_WorkboxEventTarget","registerOptions","f","_registerOptions","_updateFoundCount","_swDeferred","_activeDeferred","_controllingDeferred","_registrationTime","_ownSWs","_onUpdateFound","registration","_registration","installingSW","_scriptURL","_externalSW","_sw","_onStateChange","eventProps","_isUpdate","_waitingTimeout","_onControllerChange","_onMessage","args","_proto","_temp","_ref$immediate","_this2","body","result","_invoke","res","_compatibleControllingSW","_getControllingSWIfCompatible","_registerScript","_this2$_registerScrip","waitingSW","undefined","_this5","recover","_catch","reg","error","WorkboxEventTarget","_eventListenerRegistry","listener","_getEventListenersByType","_step","_iterator","_createForOfIteratorHelperLoose"],"version":3,"file":"workbox-window.prod.es5.94270204.js.map"}